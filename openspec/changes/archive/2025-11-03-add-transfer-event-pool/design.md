## Context

現有轉帳架構採用「重資料庫原則」，所有業務邏輯（餘額檢查、冷卻限制、每日上限、實際轉帳）都在 `fn_transfer_currency` SQL 函式中同步執行。此設計確保 ACID 一致性，但缺乏異步處理與自動重試能力。

使用者需求：
- 當轉帳因暫時性原因失敗（如冷卻期間、餘額暫時不足）時，系統應自動重試
- 支援長時間等待的轉帳請求（如等待冷卻結束後自動執行）
- 保持「重資料庫原則」，業務規則仍在資料庫層

## Goals / Non-Goals

### Goals
- 保持「重資料庫原則」：檢查邏輯保留在資料庫層（SQL 函式、觸發器）
- 事件驅動架構：使用 PostgreSQL NOTIFY/LISTEN 機制實現異步協調
- 自動重試：檢查失敗時使用指數退避策略，最多重試 10 次
- 一致性保證：檢查與轉帳仍需在同一交易中完成（當所有檢查通過時）
- 向後相容：保留現有 `fn_transfer_currency` 函式作為最終執行層

### Non-Goals
- 不改變現有同步轉帳路徑的 API（`TransferService.transfer_currency` 仍可直接呼叫 `fn_transfer_currency`）
- 不引入外部訊息佇列系統（僅使用 PostgreSQL 內建 NOTIFY/LISTEN）
- 不改變現有的權限檢查與驗證邏輯
- 不實作分散式鎖定（單一資料庫實例，使用 PostgreSQL 內建鎖定）

## Decisions

### Decision 1: 使用 `pending_transfers` 表作為事件池
**選擇**：建立 `economy.pending_transfers` 表記錄待處理轉帳請求，狀態欄位追蹤生命週期（`pending` → `checking` → `approved` / `rejected`）。

**理由**：
- 狀態持久化在資料庫中，符合「重資料庫原則」
- 查詢與索引優化簡單直接
- 支援長時間等待的請求（過期時間可設為數小時或數天）

**替代方案**：
- 使用 Redis 作為事件池：增加外部依賴，違反「重資料庫原則」
- 僅使用 NOTIFY 事件：無法追蹤狀態歷史，重試邏輯複雜

### Decision 2: 觸發器驅動檢查流程
**選擇**：插入 `pending_transfers` 時自動觸發檢查流程，各項檢查（餘額、冷卻、限額）異步執行並更新 `checks` JSONB 欄位。

**理由**：
- 檢查邏輯集中在資料庫層，符合專案架構原則
- 利用 PostgreSQL 觸發器機制，無需額外排程器
- 檢查結果透過 `pg_notify` 發送事件，Python 層可即時響應

**替代方案**：
- Python 層輪詢檢查：增加資料庫負擔，延遲較高
- 外部排程器（如 Celery）：增加複雜度與依賴

### Decision 3: Python 層監聽事件並協調執行
**選擇**：擴展現有的 `TelemetryListener` 監聽檢查結果事件，當所有檢查通過時呼叫 `fn_transfer_currency` 執行實際轉帳。

**理由**：
- 重複使用現有事件監聽基礎設施
- Python 層僅負責協調與重試邏輯，業務規則仍在資料庫層
- 符合分層架構：Commands → Service → Gateway → SQL 函式

**替代方案**：
- 完全在資料庫層處理：PostgreSQL 不適合複雜的重試與錯誤恢復邏輯
- 使用外部工作流程引擎：過度複雜，違反簡化原則

### Decision 4: 指數退避重試策略
**選擇**：檢查失敗時使用指數退避策略重試，最多 10 次，重試間隔為 `2^retry_count` 秒（上限 300 秒）。

**理由**：
- 平衡重試頻率與系統負擔
- 常見的錯誤處理模式，易於理解與維護
- 10 次重試足以覆蓋大多數暫時性失敗場景

**替代方案**：
- 固定間隔重試：無法適應不同類型的錯誤
- 線性退避：退避速度過慢

### Decision 5: 檢查與轉帳在同一交易中完成
**選擇**：當所有檢查通過時，在同一交易中呼叫 `fn_transfer_currency` 執行實際轉帳。

**理由**：
- 確保一致性：檢查結果與轉帳執行不可分割
- 利用 PostgreSQL ACID 保證，避免競態條件
- 符合現有架構模式

**替代方案**：
- 分離檢查與轉帳：增加不一致風險，需要額外的補償邏輯

## Risks / Trade-offs

### Risk 1: 事件丟失導致轉帳卡住
**風險**：如果 NOTIFY 事件丟失，Python 層可能無法感知檢查完成，轉帳請求將永久停留在 `checking` 狀態。

**緩解**：
- 實作定期輪詢機制：Python 層定期檢查 `checking` 狀態超過一定時間的記錄，重新觸發檢查
- 記錄詳細日誌：追蹤所有事件與狀態變更，便於診斷

### Risk 2: 重試邏輯增加資料庫負擔
**風險**：頻繁重試可能對資料庫造成額外負擔，特別是當大量請求同時進入重試循環時。

**緩解**：
- 使用指數退避策略降低重試頻率
- 設定合理的重試上限（10 次）與過期時間
- 監控 `pending_transfers` 表大小與查詢效能

### Risk 3: 與現有同步轉帳路徑的相容性
**風險**：新的事件池架構可能與現有的直接呼叫 `fn_transfer_currency` 路徑產生衝突。

**緩解**：
- 保留現有同步轉帳路徑不變（`TransferService.transfer_currency` 仍可直接呼叫）
- 事件池架構作為可選路徑，透過配置或參數啟用
- 逐步遷移：先實作事件池，再評估是否需要完全遷移

## Migration Plan

### Phase 1: 資料庫層基礎設施
1. 建立 `pending_transfers` 表與遷移腳本
2. 實作觸發器與檢查函式（資料庫層）
3. 新增檢查結果事件通知（`pg_notify`）

### Phase 2: Python 層事件監聽
4. 擴展 `TelemetryListener` 監聽檢查事件
5. 實作檢查狀態追蹤邏輯

### Phase 3: 協調邏輯與重試
6. 實作協調邏輯：所有檢查通過時呼叫 `fn_transfer_currency`
7. 實作重試機制（指數退避，最多 10 次）
8. 實作過期清理機制

### Phase 4: 測試與驗證
9. 單元測試：檢查函式、觸發器、事件監聽
10. 整合測試：完整轉帳流程（成功、失敗、重試）
11. 效能測試：大量併發請求的處理能力

### Rollback Plan
- 若實作出現問題，可透過資料庫遷移回滾移除 `pending_transfers` 表
- 現有同步轉帳路徑不受影響，可繼續使用
- 事件監聽擴展為可選功能，可透過配置停用

## Open Questions

1. **預設行為**：新的 `/transfer` 指令是否預設使用事件池架構，還是需要明確參數啟用？
   - **建議**：先實作為可選功能，透過環境變數或配置啟用，評估後再決定是否預設啟用

2. **過期時間**：`pending_transfers` 記錄的預設過期時間應設為多久？
   - **建議**：根據最大重試次數與退避時間計算，例如 10 次重試最多需要約 1 小時，過期時間設為 24 小時

3. **清理頻率**：過期記錄的清理頻率應為多久一次？
   - **建議**：每日清理一次（透過 `pg_cron` 或 Python 層定時任務）

4. **事件通道命名**：檢查結果事件應使用現有的 `economy_events` 通道，還是新建專用通道？
   - **建議**：使用現有 `economy_events` 通道，透過 `event_type` 區分（如 `transfer_check_result`）
